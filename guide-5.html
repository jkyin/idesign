<!DOCTYPE html>
<html lang="en">
<head>
	<title>Designing &amp; Building Wonderful iOS Animations</title>
	<meta http-equiv="content-type" content="text/html;charset=utf-8" />
	<meta name="author" content="Mike Rundle" />
	<link rel="stylesheet" href="guide.css" />
	<script src="common/common.js"></script>
</head>
<body>
	<div id="wrapper">

	<header>
		<h1>Motion Design for iOS<small>Section 5</small><em>By Mike Rundle</em></h1>
	</header>

	<section>

		<h2>Building Jeff Broderick’s Map Animation</h2>

		<p>Earlier in this guide I featured a great animation that <a href="http://brdrck.me/">Jeff Broderick</a> had designed and posted to Dribbble.</p>

		<figure>
			<img class="full" src="images/map.gif" />
			<figcaption>Animation by <a href="https://dribbble.com/brdrck">Jeff Broderick.</a></figcaption>
		</figure>

		<p>As I noted, there are a few different animations happening here. First, when the map icon is tapped, the main interface of the application (including the navigation bar) has both an opacity and scale animation to make it fade into the black background and also get a little smaller. At the same time, the map is brought forth with an opacity and scale animation so that it’s prominently displayed at the front of the interface. The map also moves upwards on the screen a little bit as well with a translation animation. The map icon stays in place.</p>

		<p>Before we jump into the code to recreate Jeff’s animation, here’s a peek at the final animation that we’ll be building.</p>

		<figure>
			<img src="images/map2.gif" />
		</figure>

		<p>I’ll be reproducing this animation by using some simple <code class="prettyprint">UIImageView</code>s and <code class="prettyprint">UIButton</code>s as it’s mostly to get the feel of the animation timings right, but in reality the map would be an actual map view that could be pinch-zoomed. You can follow along with this code in <strong>Map Example</strong> Xcode project.</p>

		<p>To start, let’s add the image representing the main interface of the app.</p>

		<pre class="prettyprint">// Add the main app background image
self.appBackground = [[UIImageView alloc] initWithFrame:CGRectMake(0, 20,
    self.window.bounds.size.width, 548)];
self.appBackground.image = [UIImage imageNamed:@"app-bg"];
[self.window addSubview:self.appBackground];</pre>

		<p>We’ve added a simple <code class="prettyprint">UIImageView</code> with <code class="prettyprint">"app-bg@2x.png"</code> assigned to its <code class="prettyprint">image</code> property. The app runtime is smart enough to know that if you write <code class="prettyprint">"app-bg"</code>, it’ll find <code class="prettyprint">"app-bg@2x.png"</code> in your image resources within the app bundle. This view has been added as a <code class="prettyprint">@property</code> on the class so that we can reference it later on in our code. Here’s how you declare a <code>@property</code>.</p>

		<pre class="prettyprint">@property (assign) UIImageView *appBackground;</pre>

		<p>This <code>@property</code> is defined either in the <code>@interface</code> in the <code>.h</code> file for the class, or in the <code>@interface</code> block in the <code>.m</code> implementation file which will make this <code>@property</code> private. Read more about properties in the <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html">Programming with Objective-C</a> guide at Apple’s Developer site.</p>

		<p>Finally, we add the <code>UIImageView</code> as a subview on the main <code>window</code>. This is a quick prototype, otherwise I’d create a separate <code>UIViewController</code> subclass to house our UI code that we’ve written.</p>

		<p>If we build and run, this is what the app looks like at this stage.</p>

		<figure>
			<img src="images/map1.png" />
		</figure>

		<p>Exciting! Okay, now let’s add the map which will be transparent and have a transform applied to start with. We’re adding it right after the main application image because we want to add the icon button last as it will be at the highest z-index will be on top of the other views.</p>

		<pre>// Add the map view
self.mapView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 62,
    self.window.bounds.size.width, 458)];
self.mapView.image = [UIImage imageNamed:@"map-arrow"];
self.mapView.alpha = 0.0f;
self.mapView.transform = CGAffineTransformMakeTranslation(0, 30);
self.mapView.transform = CGAffineTransformScale(self.mapView.transform, 1.1, 1.1);
[self.window addSubview:self.mapView];</pre>

		<p>The <code>frame</code> for the map view starts in the top left corner at position 0 but is pushed down 62 pixels from the top so that it sits just underneath the map icon button we’ll be adding in a bit. The <code>image</code> property is set to <code>"map-arrow"</code> which is just a map image I put together with an arrow at the top to emulate the design that Jeff put together for his animation.</p>

		<p>At the start, this view will be totally transparent so the <code>alpha</code> property has been set to <code>0</code>. There are two <code>transform</code>s applied to the view: the first translates the view down 30 pixels and the second scales it up to 1.1&times; the normal size.</p>

		<p>Here’s what it looks like at this stage if I comment out the <code>alpha</code> line so we can see where the map is.</p>

		<figure>
			<img src="images/map2.png" />
		</figure>

		<p>That looks like about the right position to start off the animation. Now let’s add our icon button.</p>

		<pre>// Add the icon
UIButton *icon = [UIButton buttonWithType:UIButtonTypeCustom];
[icon setImage:[UIImage imageNamed:@"map-icon"] forState:UIControlStateNormal];
[icon addTarget:self action:@selector(didTapMapIcon:)
    forControlEvents:UIControlEventTouchUpInside];
[icon setFrame:CGRectMake(self.window.bounds.size.width - 49, 19, 49, 44)];
[self.window addSubview:icon];</pre>

		<p>This is a pretty typical way to add an icon button. The <code>UIButton</code> class has a convenient way to construct a button: the <code>+buttonWithType:</code> class method. I passed in <code>UIButtonTypeCustom</code> as a button type which means no default styles will be applied, it’s totally up to me. This is useful with simple icon buttons as there’s no border or other weird styles to remove. It’s a bit like a CSS reset on the button.</p>

		<p>I then set the image of the button to be the <code>"map-icon"</code> image in my app bundle. The parameter <code>UIControlStateNormal</code> means that this icon will be displayed as the regular image for this button in its normal, default state. You can set this value multiple times with various images in case you want to change the icon for just the <code>UIControlStateHighlighted</code> state for example. By default, when a <code>UIButton</code> is tapped, iOS will darken the image automatically.</p>

		<p>Finally, I make it so the button can be tapped on and it will call a method that I define. The <code>self</code> parameter value means that I want this button to call the class I’m currently in when it’s tapped, and then <code>@selector(didTapMapIcon:)</code> is the Objective-C method I want to be called. Then I positioned the button at the exact spot I wanted by setting its <code>frame</code>.</p>

		<p>Let’s see what the app looks like in this state, with the map back to an <code>alpha</code> of 0 so its invisible.</p>

		<figure>
			<img src="images/map3.png" />
		</figure>

		<p>Okay, now that we have all the core components of the animation added to the interface, it’s time to add some animation action for when the map icon button is tapped.</p>

		<p>First, we need to implement the method that will be called when the button gets tapped. Here’s what that method looks like with nothing inside of it.</p>

		<pre>- (void)didTapMapIcon:(id)sender {
    // Nothing here yet!
}</pre>

		<p>This will be called when a user taps on the map icon button because that’s how we set it up by using the <code>-addTarget:action:forControlEvents:</code> method from before.</p>

		<p>So, logically, when you tap the button, one of two things should happen: we should animate the map into view, or we should animate the map <em>out of</em> view if it’s already visible. We could inspect our interface elements and see where they’re positioned to figure out what we should do, but that’s sort of a hack so let’s track it with a simple <code>BOOL</code> variable instead as a <code>@property</code> on the class. At the top of this file I added a <code>BOOL</code> variable named <code>mapShowing</code> to manage whether we need to open or close the map view. This property will be next to our button method and the other properties we’ve added to hold onto our main views of the interface.</p>

		<pre>@interface DTCAppDelegate ()

- (void)didTapMapIcon:(id)sender;

@property (assign) BOOL mapShowing;

@property (strong) UIImageView *appBackground;
@property (strong) UIImageView *mapView;

@end</pre>

		<p>Now, back to our button tapped method, we need to add in some logic here that will check if the map is showing or not, and then set the variable to the opposite.</p>

		<pre>- (void)didTapMapIcon:(id)sender {
	
if (self.mapShowing) {	
    self.mapShowing = NO;

    // Code for when the map is already visible goes here
} else {
    self.mapShowing = YES;

    // Code for when the map is not visible yet goes here
}</pre>

		<p>Let’s start with the <code>else</code> case where the map is not currently showing and the opacity animations we need to do. What we need to do is fade out the main app background a bit and then fade in the map. The main app background will be faded out a little slower than the map will be faded in so the map pops a bit more visually.</p>

		<pre>[UIView animateWithDuration:.5 delay:0 
    options:UIViewAnimationOptionCurveEaseInOut|UIViewAnimationOptionBeginFromCurrentState 
    animations:^{
    self.appBackground.alpha = 0.3f;
} completion:NULL];
		
[UIView animateWithDuration:.15 delay:0
    options:UIViewAnimationOptionCurveEaseInOut|UIViewAnimationOptionBeginFromCurrentState 
    animations:^{
	self.mapView.alpha = 1.0f;
} completion:NULL];</pre>

		<p>You’ll probably notice the gigantic parameter being passed into the <code>options</code> argument to these block-based <code>UIView</code> animation methods. This is actually 2 options combined together with the binary <code>|</code> operator: <code>UIViewAnimationOptionCurveEaseInOut</code> to define the animation easing and <code>UIViewAnimationOptionBeginFromCurrentState</code> which will animate the <code>alpha</code> property starting from its <em>current value</em> so if the animated is interrupted, it doesn’t jerk back to the original value before starting the animation over. This is really important on an animation like this that’s governed by a user action because you don’t know if the user will tap the button over and over while the animation is happening and you certainly don’t want to do <em>nothing</em> until the animation is complete.</p>

		<p>Of course, adjusting the opacity of the main app interface and the map doesn’t actually complete our animation because we still need to animate the map’s <code>scale</code> and <code>translation</code> so that it can arrive at its final position and final size. For the main app interface, we will just be animating its <code>scale</code> a bit.</p>

		<p>Even though these animations could be accomplished using an ease-out animation timing, I’ll go ahead and use a spring animation with equal <code>damping</code> and <code>stiffness</code> values so I can tweak the slow-down. There will be no bouncing here, just a really smooth, gradual transition.</p>

		<pre>CGFloat dampingStiffness = 16.0f;

// Scale animation for the main app background
JNWSpringAnimation *scale =
    [JNWSpringAnimation animationWithKeyPath:@"transform.scale"];
scale.damping = dampingStiffness;
scale.stiffness = dampingStiffness;
scale.mass = 1;
scale.fromValue = @([[self.appBackground.layer.presentationLayer
    valueForKeyPath:scale.keyPath] floatValue]);
scale.toValue = @(0.9);

[self.appBackground.layer addAnimation:scale forKey:scale.keyPath];
self.appBackground.transform =
    CGAffineTransformScale(CGAffineTransformIdentity, .9, .9);</pre>

		<p>I set the <code>damping</code> and <code>stiffness</code> values to a <code>CGFloat</code> variable so I could tweak them more easily without having to update both values at once.</p>

		<p>One of the key changes in this block of code that’s different from other examples is that the <code>fromValue</code> on the <code>scale</code> animation object is not set to a static value, but rather it’s set to <code>[[self.appBackground.layer.presentationLayer
    valueForKeyPath:scale.keyPath] floatValue]</code>. Now what does that mean? If you break it down piece by piece, this is what is happening:</p>

    	<ul>
    		<li>I’m accessing the <code>appBackground</code> property on this class using <code>self.appBackground</code></li>
    		<li>I’m getting the <code>CALayer</code> object of this view</li>
    		<li>I’m getting the <code>presentationLayer</code> property on the layer, which is how you can access the special <em>presentation model layer</em> which lets us see the in-flight values of the animation as they are changing</li>
    		<li>Once I have the <code>presentationLayer</code>, I’m calling <code>-valueForKeyPath:</code> on it to fetch the current value of the transform’s <code>scale</code> component. (<code>scale.keyPath</code> = <code>@"transform.scale"</code>)</li>
    		<li>And when I finally have the current scale value, it’s not in the number format I need it to be in to use within JNWSpringAnimation, so I get the <code>-floatValue</code> of it.</li>
    	</ul>

    	<p>Remember earlier I mentioned that the value of various properties on a layer don’t change during the animation? And that the <em>presentation model layer</em> is used by Core Animation to actually store the accurate in-flight values while an animation is occurring? Well since we need to get at the actual, current value of the scale transform so that we can animate it from whatever spot it’s currently at (remember if the user gets tap-happy we don’t want the animation to start over!) we need to access the special presentation layer to read the value. Then, we use that as the <code>fromValue</code> in our animation, and it’ll always work nicely no matter if the <code>fromValue</code> is the normal, untouched scale value we set on the view, or somewhere in between if it’s being animated at that exact moment. If we didn’t access it via the <code>presentationLayer</code>, the value would never be right if it was currently animating as that value doesn’t update until the animation is over with!</p>

    	<p>We don’t just need to animate the main app background, we also need to animate the map itself so that its scale can shrink down to a 1.0 size and also move up on the screen with a translation. Let’s do that now.</p>

    	<pre>// Map gets 2 separate animations, one for position and the other for scale
JNWSpringAnimation *mapScale =
    [JNWSpringAnimation animationWithKeyPath:@"transform.scale"];
mapScale.damping = dampingStiffness;
mapScale.stiffness = dampingStiffness;
mapScale.mass = 1;
mapScale.fromValue =
    @([[self.mapView.layer.presentationLayer valueForKeyPath:mapScale.keyPath] floatValue]);
mapScale.toValue = @(1.0);

[self.mapView.layer addAnimation:mapScale forKey:mapScale.keyPath];
self.mapView.transform = CGAffineTransformScale(CGAffineTransformIdentity, 1, 1);

JNWSpringAnimation *mapTranslate =
    [JNWSpringAnimation animationWithKeyPath:@"transform.translation.y"];
mapTranslate.damping = dampingStiffness;
mapTranslate.stiffness = dampingStiffness;
mapTranslate.mass = 1;
mapTranslate.fromValue =
    @([[self.mapView.layer.presentationLayer valueForKeyPath:mapTranslate.keyPath] floatValue]);
mapTranslate.toValue = @(0);

[self.mapView.layer addAnimation:mapTranslate forKey:mapTranslate.keyPath];
self.mapView.transform = CGAffineTransformTranslate(self.mapView.transform, 0, 0);</pre>

		<p>Nothing too fancy going on here besides accessing the current, in-flight value to start from again just like in the previous animation. I’m also reusing the <code>damping</code> and <code>stiffness</code> variable here so that the animations all feel like they’re happening with the same type of motion.</p>

		<p>So that’s a decent chunk of code, but fortunately it’s fairly straightforward, and by now you should be used to what a JNWSpringAnimation code chunk looks like. Here’s what the animation looks like at this stage.</p>

		<figure>
			<img src="images/map3.gif" />
		</figure>

		<p>Now it’s time to add the animations for the other side of this interaction, which is when the user taps on the map icon while the map is visible, and the motions we want to execute to fade it back out and bring the main app interface to the foreground. Since it’s identical to the animation code we just showed, apart from the starting and final values, here it is in one big chunk with comments to explain what’s happening.</p>

		<pre>if (self.mapShowing) {
		
    self.mapShowing = NO;

    // Re-using the same damping and stiffness throughout these animations
    // so we’ll capture the value as a CGFloat variable. Notice that this value is
    // higher which means the animation will take less time (as is the case with
    // spring animations with matching damping and stiffnesses). Less time is good
    // because we’re going back to the default state of the interface and at this point
    // the user just wants the map to get out of the way.
    CGFloat dampingStiffnessOut = 24.0f;

    // Again, it’s important to begin from the current state so that when a user taps
    // on the button a bunch, there are no jerky movements
    [UIView animateWithDuration:.5 delay:0 
        options:UIViewAnimationOptionCurveEaseInOut|UIViewAnimationOptionBeginFromCurrentState
        animations:^{
    	self.appBackground.alpha = 1.0f;
    } completion:NULL];

    [UIView animateWithDuration:.3 delay:0
        options:UIViewAnimationOptionCurveEaseInOut|UIViewAnimationOptionBeginFromCurrentState 
        animations:^{
    	self.mapView.alpha = 0.0f;
    } completion:NULL];

    // Map gets 2 separate animations, one for position and the other for scale.
    // We are accessing the @"transform.scale" current, in-flight values via the
    // presentationLayer just like in the previous example
    JNWSpringAnimation *mapScale =
        [JNWSpringAnimationanimationWithKeyPath:@"transform.scale"];
    mapScale.damping = dampingStiffnessOut;
    mapScale.stiffness = dampingStiffnessOut;
    mapScale.mass = 1;
    mapScale.fromValue =
        @([[self.mapView.layer.presentationLayer
        valueForKeyPath:mapScale.keyPath] floatValue]);
    mapScale.toValue = @(1.1);

    [self.mapView.layer addAnimation:mapScale forKey:mapScale.keyPath];
    self.mapView.transform =
        CGAffineTransformScale(CGAffineTransformIdentity, 1.1, 1.1);

    JNWSpringAnimation *mapTranslate =
        [JNWSpringAnimation animationWithKeyPath:@"transform.translation.y"];
    mapTranslate.damping = dampingStiffnessOut;
    mapTranslate.stiffness = dampingStiffnessOut;
    mapTranslate.mass = 1;
    mapTranslate.fromValue =
        @([[self.mapView.layer.presentationLayer
        valueForKeyPath:mapTranslate.keyPath] floatValue]);
    mapTranslate.toValue = @(30);

    [self.mapView.layer addAnimation:mapTranslate forKey:mapTranslate.keyPath];
    self.mapView.transform = CGAffineTransformTranslate(self.mapView.transform, 0, 30);

    // Scale animation for the main app background. We animate it back to a 1.0 scale
    JNWSpringAnimation *scale =
        [JNWSpringAnimation animationWithKeyPath:@"transform.scale"];
    scale.damping = dampingStiffnessOut;
    scale.stiffness = dampingStiffnessOut;
    scale.mass = 1;
    scale.fromValue =
        @([[self.appBackground.layer.presentationLayer
        valueForKeyPath:@"transform.scale.x"] floatValue]);
    scale.toValue = @(1.0);

    [self.appBackground.layer addAnimation:scale forKey:scale.keyPath];
    self.appBackground.transform =
        CGAffineTransformScale(CGAffineTransformIdentity, 1.0, 1.0);

}</pre>

		<p>Here’s what the full, final animation looks like if you click around like a mad-man to show that the animations do start from their present values and there’s no jerkiness.</p>

		<figure>
			<img src="images/map4.gif" />
		</figure>

		<p>That was fun! Now let’s dive into something that has some stuttered animations.</p>

		<h2>Building Jakub Antalík’s Music Player</h2>

		<p>Jakub is an outstanding designer from Slovakia and has designed some really creative interfaces that he frequently posts to <a href="https://dribbble.com/antalik">Dribbble</a>. One of his shots really stood out in my mind as a fun example of how stuttered animations that build-in the interface one element at a time can really draw a user’s eye. Earlier in this guide I posted a music player that he designed that had some cool build-in animations, here it is again.</p>

		<figure>
			<img class="full" src="images/music.gif" />
			<figcaption>Animation by <a href="https://dribbble.com/antalik">Jakub Antalík</a></figcaption>
		</figure>

		<p>So what is the distinct technique that he’s using here? <em>He’s manipulating the start time of the animations.</em> By having each element animate into place on the screen a fraction of a second behind another element, and carrying that sequence down the line for every element on the screen, it makes a really neat “wave” type of effect that feels like each element is attached to the previous element by a rubber band.</p>

		<p>Let’s recreate the 2nd screen in his music player concept: the listing of the songs.</p>

		<p>First, we need to recreate the design so that we can slice up the elements and animate them individually as cleanly as we can. I pulled out my design tool of choice, Photoshop, and got to work. The file <strong>musicplayer.psd</strong> is where the design is stored so open it up and check it out if you’d like. I won’t go into detail about how I created the design in Photoshop, but the file and design is simple enough that it should be pretty straightforward.</p>

		<p>Here’s my recreated 2nd screen song listing.</p>

		<figure>
			<img src="images/musicplayer.png" />
		</figure>

		<p>If you look carefully at the original animation, there are 8 distinct elements that are animated separately.</p>

		<ol>
			<li>The back arrow and the “Dance Club” label</li>
			<li>The “Ministry of Fun” label</li>
			<li>The “Add a Song” button</li>
			<li>Each of the 5 song rows</li>
		</ol>

		<p>These 8 elements (or groups of elements since the arrow and “Dance Club” label are animated together) are all stutter-stepped into view by varying the start time of the animation, and that’s exactly what we’ll be altering to get the cool wave-like effect as everything animates into view.</p>

		<p>Let’s first put together a plan of attack. What I need to do is add these elements separately to the interface so that I can animate them separately. If this were a real app with real data being fed into it, this screen would most likely be powered by a <code>UITableView</code> or <code>UICollectionView</code> to have a nice, structured way of laying out the rows. The high-level overview of those two types of views is that you implement their <em>protocols</em> which are a set of methods you need to define to return some data to the interface, like a method to return the height of a row, or another method that returns a view for 1 row. Since we don’t have any data, and my main goal is to just demonstrate how we can build the animations, I’m just going to save PNGs from my Photoshop file of the design and add each of these elements manually to the screen, starting with the top arrow and “Dance Club” label. You can follow along in the <strong>Music Player</strong> Xcode project.</p>

		<pre>// Define a variable to get the full width of the window as we’ll
// be using this value a lot.
CGFloat windowWidth = self.window.bounds.size.width;

// Add the background to the window
UIImageView *backgroundView = [[UIImageView alloc] initWithFrame:self.window.bounds];
backgroundView.image = [UIImage imageNamed:@"background"];
[self.window addSubview:backgroundView];

// Add the arrow and top label
UIImageView *arrowView =
    [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, windowWidth, 45)];
arrowView.image = [UIImage imageNamed:@"arrow"];
[self.window addSubview:arrowView];</pre>

		<p>Nothing fancy is happening here, it’s just simply adding a few views to the main window of our prototype. The image named <code>@"background"</code> is just the big, blown-out gradient image that will serve as the backdrop for the rest of our views. The <code>@"arrow"</code> image was exported from my Photoshop mockup to contain both the arrow and the “Dance Club” label since I’ll be animating them together, I thought it was simple to just include them in the same image.</p>

		<p>Here’s what the interface looks like at this stage.</p>

		<figure>
			<img src="images/music1.png" />
		</figure>

		<p>Now let’s add a few more views!</p>

		<pre>// Ministry of Fun image
UIImageView *ministryView =
    [[UIImageView alloc] initWithFrame:CGRectMake(0, 57, windowWidth, 28)];
ministryView.image = [UIImage imageNamed:@"ministry"];
[self.window addSubview:ministryView];

// Add a Song button
UIButton *addButton = [UIButton buttonWithType:UIButtonTypeCustom];
[addButton setImage:[UIImage imageNamed:@"add-button"] forState:UIControlStateNormal];
[addButton setImage:[UIImage imageNamed:@"add-button-pressed"]
    forState:UIControlStateHighlighted];
[addButton setFrame:CGRectMake(0, 102, windowWidth, 45)];
[self.window addSubview:addButton];</pre>

		<p>I added the “Ministry of Fun” image view (using the PNG image I sliced out of my Photoshop mockup) to the window, and then created a <code>UIButton</code> for the “Add a Song” button. I could have been lazy and not made the button an actual <code>UIButton</code> but instead just use a <code>UIImageView</code> but I wanted to show the ability of setting the pressed and normal images on a custom <code>UIButton</code>. You just call the same <code>-setImage:forState:</code> method but with a different state property passed in. You can call this as many times as you want with different state properties each time to cover every single possibility for user interaction on the button if you were so inclined. Then, I set the frame of the button and added it to the window as well.</p>

		<p>Here’s the interface at this stage and a little demonstration of the tap state of the button.</p>

		<figure>
			<img src="images/musicbutton.gif" />
		</figure>

		<p>The image for our <code>UIControlStateHighlighted</code> state is just a white fill instead of the white stroke.</p>

		<p>Now let’s add in all of our rows. They’re all <code>UIImageView</code>s as well so it’s another straightforward placement of a view with a background image.</p>

		<pre>// Katy Perry row
UIImageView *firstRow =
    [[UIImageView alloc] initWithFrame:CGRectMake(0, 170, windowWidth, 80)];
firstRow.image = [UIImage imageNamed:@"1st-row"];
[self.window addSubview:firstRow];

// Shakira row
UIImageView *secondRow =
    [[UIImageView alloc] initWithFrame:CGRectMake(0, 170+80, windowWidth, 80)];
secondRow.image = [UIImage imageNamed:@"2nd-row"];
[self.window addSubview:secondRow];

// Pitbull row
UIImageView *thirdRow =
    [[UIImageView alloc] initWithFrame:CGRectMake(0, 170+160, windowWidth, 80)];
thirdRow.image = [UIImage imageNamed:@"3rd-row"];
[self.window addSubview:thirdRow];

// Lana del Rey row
UIImageView *fourthRow =
    [[UIImageView alloc] initWithFrame:CGRectMake(0, 170+240, windowWidth, 80)];
fourthRow.image = [UIImage imageNamed:@"4th-row"];
[self.window addSubview:fourthRow];

// HEX row
UIImageView *fifthRow =
    [[UIImageView alloc] initWithFrame:CGRectMake(0, 170+320, windowWidth, 80)];
fifthRow.image = [UIImage imageNamed:@"5th-row"];
[self.window addSubview:fifthRow];</pre>

			<p>You might notice that the Y coordinate (vertical position) in each row’s <code>frame</code> has a little math equation. Each row is 80px tall, so to position them one after another I’m just adding a multiple of 80 to the Y position. I could use <a href="https://developer.apple.com/Library/ios/documentation/UserExperience/Conceptual/AutolayoutPG/Introduction/Introduction.html">Auto Layout</a> to do this but it’s a little overkill for an example like this.</p>

			<p>Here’s a screenshot of the final interface before adding in any adjustments for the animation.</p>

			<figure>
				<img src="images/music2.png" />
			</figure>

			<p>But wait, we don’t want the interface to actually look like this when you first bring it up. The whole point of this exercise is to animate each of these elements into position which means they shouldn’t be at their final position off the bat. What I want to do is start each element <em>off the screen</em> to the right to start off, and then I’ll animate the left side of each element back to the left side of the screen for the final value.</p>

			<p>Let’s go back to our view setup code and modify each element’s <code>frame</code> so that its X axis position value is no longer 0, but <code>windowWidth.</code> That will align the left edge of each element to the right side of the screen so that its hidden to the user.</p>

			<pre>// Add the arrow and top label
UIImageView *arrowView =
   [[UIImageView alloc] initWithFrame:CGRectMake(windowWidth, 0, windowWidth, 45)];
arrowView.image = [UIImage imageNamed:@"arrow"];
[self.window addSubview:arrowView];

// Ministry of Fun label
UIImageView *ministryView =
    [[UIImageView alloc] initWithFrame:CGRectMake(windowWidth, 57, windowWidth, 56/2)];
ministryView.image = [UIImage imageNamed:@"ministry"];
[self.window addSubview:ministryView];

// Add a Song button
UIButton *addButton = [UIButton buttonWithType:UIButtonTypeCustom];
[addButton setImage:[UIImage imageNamed:@"add-button"]
    forState:UIControlStateNormal];
[addButton setImage:[UIImage imageNamed:@"add-button-pressed"]
    forState:UIControlStateHighlighted];
[addButton setFrame:CGRectMake(windowWidth, 102, windowWidth, 45)];
[self.window addSubview:addButton];

// Katy Perry row
UIImageView *firstRow =
    [[UIImageView alloc] initWithFrame:CGRectMake(windowWidth, 170, windowWidth, 80)];
firstRow.image = [UIImage imageNamed:@"1st-row"];
[self.window addSubview:firstRow];

// Shakira row
UIImageView *secondRow =
    [[UIImageView alloc] initWithFrame:CGRectMake(windowWidth, 170+80, windowWidth, 80)];
secondRow.image = [UIImage imageNamed:@"2nd-row"];
[self.window addSubview:secondRow];

// Pitbull row
UIImageView *thirdRow =
    [[UIImageView alloc] initWithFrame:CGRectMake(windowWidth, 170+160, windowWidth, 80)];
thirdRow.image = [UIImage imageNamed:@"3rd-row"];
[self.window addSubview:thirdRow];

// Lana del Rey row
UIImageView *fourthRow =
    [[UIImageView alloc] initWithFrame:CGRectMake(windowWidth, 170+240, windowWidth, 80)];
fourthRow.image = [UIImage imageNamed:@"4th-row"];
[self.window addSubview:fourthRow];

// HEX row
UIImageView *fifthRow =
    [[UIImageView alloc] initWithFrame:CGRectMake(windowWidth, 170+320, windowWidth, 80)];
fifthRow.image = [UIImage imageNamed:@"5th-row"];
[self.window addSubview:fifthRow];</pre>

		<p>You can probably imagine what the interface looks like at this stage with everything moved over to the right off the screen, it’s just the background image showing now.</p>

		<p>Now that everything is off the screen and ready to be animated, the strategy is that we’re going to animate each one to the left, one at a time, with a slightly delayed starting time for each one so they have a wave-like pattern. Just for fun, for this example, let’s use the block-based <code>UIView</code> animation methods to animate our elements across the screen.</p>

		<p>Here’s the first animation block where we’ll be sliding the arrow and “Dance Club” image to the left.</p>

		<pre>[UIView animateWithDuration:1.1 delay:0 usingSpringWithDamping:0.3
    initialSpringVelocity:0 options:0 animations:^{
    [arrowView setFrame:CGRectMake(0, 0, windowWidth, 45)];
} completion:NULL];</pre>

		<p>This block-based animation has a 1.1 second duration and a spring damping of 0.3. The duration is how long the animation takes to complete, and the damping is a spring property that iOS 7 provides in this <code>UIView</code> animation method to control the springiness of the spring. JNWSpringAnimation provides 3 properties to control the physics of the spring, but Apple only really provides 1, this damping property. The way that Apple has built this method, the damping has to be a value between 0 and 1, and the closer to 0 it is, the springier the spring motion. The closer to 1 it gets, the fewer bounces until it doesn’t bounce it all and gradually eases to the final value.</p>

		<p>Let’s take a look at the motion these <code>duration</code> and <code>damping</code> values produce.</p>

		<figure>
			<img src="images/musicbutton2.gif" />
		</figure>

		<p>Hmm, well that’s way off the mark. The animation is both way too fast and also way too <em>taught</em> and springy. This kind of spring animation introduces some anxiety to the interface with the way that it animates into place. This is a great example of how <em>just using a spring animation</em> doesn’t improve your app’s overall user experience. Every kind of animated motion induces some type of feeling in your user, and this induces the wrong feelings.</p>

		<p>Let’s increase the duration up to 2.1 seconds and see how it feels.</p>

		<figure>
			<img src="images/musicbutton3.gif" />
		</figure>

		<p>That’s just way too bouncy compared to Jakub’s original animation, we need to adjust the damping value as well. Let’s move the damping from .3 up to .6 which, as I mentioned previously, is closer to the magical 1 value where it doesn’t bounce at all. We still want a little bit of a bounce, so let’s see what this looks like.</p>

		<figure>
			<img src="images/musicbutton4.gif" />
		</figure>		

		<p>Okay, that’s not too bad there. You can see that when you use the spring animation methods built into iOS 7, it definitely takes a little massaging of the values to get something that feels the way you want. The spring properties that JNWSpringAnimation exposes are a little easier to grok, at least for me, as they all manipulate distinct properties of the spring’s motion equation. The damping value in iOS 7’s block-based animation methods is actually an <em>interpreted</em> value which means Apple takes whatever value you plug into it, does some fancy math to manipulate the value and then plugs it into its internal spring motion equation. You can tell that Apple manipulates the value because it forces the lower and upper bounds to be 0 and 1 respectively. Also, in a real spring motion equation, the duration of the motion (when it finally arrives at the equilibrium point or final value) is derived from the other spring properties, it’s not something you <em>set</em> and force the spring to adhere to. Apple’s animation method has a duration that you need to set so, again, you’re manipulating the spring motion in a way that’s not completely adhering to the laws of physics governing masses attached to springs. That’s why I prefer using JNWSpringAnimation (or Facebook Pop which we’ll cover in a bit!) as they have more natural, realistic spring motions.</p>

		<p>Now, let’s animate the other elements on the screen, from top to bottom. Each one needs to be started a little bit later than the previous element. Also, I want to be able to control how long after app startup before the animation starts, so take a look at how I’ll manage that.</p>

		<pre>CGFloat initialDelay = 1.0f;
CGFloat stutter = 0.3f;

// Animate the top arrow image
[UIView animateWithDuration:2.1 delay:initialDelay
    usingSpringWithDamping:0.6 initialSpringVelocity:0 options:0 animations:^{
    [arrowView setFrame:CGRectMake(0, 0, windowWidth, 45)];
} completion:NULL];

// Animate the image label Ministry of Fun
[UIView animateWithDuration:2.1 delay:initialDelay + (1 * stutter)
    usingSpringWithDamping:0.6 initialSpringVelocity:0 options:0 animations:^{
    [ministryView setFrame:CGRectMake(0, 57, windowWidth, 28)];
} completion:NULL];</pre>

		<p>I’ve setup two <code>CGFloat</code> variables to store, in one place, an initial delay value and a value I’m calling <em>stutter</em> which will be the slight delay (in seconds) between each of our animations. This number is very important in dictating the overall feel and fluidness of our build-in animation effect. Too much timing delay between each animation and they’ll feel disconnected, too little and there won’t be enough of a wave-like effect which is what we’re trying to build.</p>

		<p>Back to the code: the <code>delay</code> property on the first animation is just the <code>initialDelay</code> variable value as this is the first animation to show on the screen. The second animation block has a <code>delay</code> value of <code>initialDelay + (1 * stutter)</code>. This means that it’ll wait the initial amount of time, and then wait another amount of time equal to the <code>stutter</code> value multiplied by 1, because this is the 1st animation that will require a stutter delay. All the other animations down the page will follow this same formula for their delay and the coefficients will progress by 1 each time with a 2 and a 3 and a 4 and so on for each animated element. This will insure they all have the same delay between the previously animated element and the next.</p>

		<p>Here’s what it looks like at this point.</p>

		<figure>
			<img src="images/musicbutton5.gif" />
		</figure>

		<p>I think this looks okay at this point. To be honest, it’s tough to see if the wave-like effect looks good when you’re only animating 2 elements in sequence because you can’t get a real feel for the overall effect unless a bunch of things are being animated. So let’s go ahead and animate the rest of our elements on the screen.</p>

<pre>[UIView animateWithDuration:2.1 delay:initialDelay + (2 * stutter)
    usingSpringWithDamping:0.6 initialSpringVelocity:0 options:0 animations:^{
    [addButton setFrame:CGRectMake(0, 102, windowWidth, 45)];
} completion:NULL];

[UIView animateWithDuration:2.1 delay:initialDelay + (3 * stutter)
    usingSpringWithDamping:0.6 initialSpringVelocity:0 options:0 animations:^{
    [firstRow setFrame:CGRectMake(0, 170, windowWidth, 80)];
} completion:NULL];

[UIView animateWithDuration:2.1 delay:initialDelay + (4 * stutter)
    usingSpringWithDamping:0.6 initialSpringVelocity:0 options:0 animations:^{
    [secondRow setFrame:CGRectMake(0, 170+80, windowWidth, 80)];
} completion:NULL];

[UIView animateWithDuration:2.1 delay:initialDelay + (5 * stutter)
    usingSpringWithDamping:0.6 initialSpringVelocity:0 options:0 animations:^{
    [thirdRow setFrame:CGRectMake(0, 170+160, windowWidth, 80)];
} completion:NULL];

[UIView animateWithDuration:2.1 delay:initialDelay + (6 * stutter)
    usingSpringWithDamping:0.6 initialSpringVelocity:0 options:0 animations:^{
    [fourthRow setFrame:CGRectMake(0, 170+240, windowWidth, 80)];
} completion:NULL];

[UIView animateWithDuration:2.1 delay:initialDelay + (7 * stutter)
    usingSpringWithDamping:0.6 initialSpringVelocity:0 options:0 animations:^{
    [fifthRow setFrame:CGRectMake(0, 170+320, windowWidth, 80)];
} completion:NULL];</pre>

		<p>Now that we’ve animated all our elements into place, let’s get a feel for how it looks.</p>

		<figure>
			<img src="images/musicbutton7.gif" />
		</figure>

		<p>This doesn’t feel right to me yet. It really seems like the timing delay between each animation is too long and disrupts the wave-like motion it’s supposed to have. It doesn’t seem fluid at all. Let’s drop the delay time a bit by changing the stutter variable from 0.3 down to 0.15 and see what it does.</p>

		<figure>
			<img src="images/musicbutton8.gif" />
		</figure>

		<p>We’re definitely getting closer but I think we can shrink the delay down a little bit more to make it feel a little more fluid and organic, like each element is just subtly tugging on the next. Let’s change the stutter variable down to 0.06.</p>

		<figure>
			<img src="images/musicbutton9.gif" />
		</figure>		

		<p>Ahh, now we’re getting somewhere. I think this looks pretty good and it has a nice, wave-like motion that doesn’t take too long to complete. Let’s compare it back to Jakub’s original animation.</p>

		<figure>
			<img class="full" src="images/music.gif" />
			<figcaption>Animation by <a href="https://dribbble.com/antalik">Jakub Antalík</a></figcaption>
		</figure>

		<p>Looks like we came pretty close to matching it up! So what did learn from this example?</p>

		<ul>
			<li>The spring damping value in the block-based <code>UIView</code> animation method is an interpreted value that takes some fiddling with to get a good feeling from. This is why I like to use a real spring motion (without a duration) like the kind provided by JNWSpringAnimation</li>
			<li>When implementing a build-in animation like this, tweaking the delay between each animation is critical to achieving a nice, wave-like motion and not a motion that feels choppy.</li>
		</ul>

		<p>I actually use a wave-like, build-in animation in my own iPhone app, <a href="http://flyosity.com/interesting/">Interesting</a> when the app first starts up. Let’s take a look at my app’s initial animation and build it.</p>

		<h2>Animating Interesting’s Stories Into Position</h2>

		<p>When my news app Interesting first starts up, I fire off a network request to pull down the latest articles. When that network request comes back, I need to populate a <code>UITableView</code> with the article data, one article per row. Some apps choose to fade the whole table in once the data is back, some will slide the rows down one by one into position, and others just immediately show the row without any sort of animation. I chose to use a build-in effect like the kind we just built for that music player, but instead of animating items horizontally, I animate them up from the bottom vertically. Here’s what my initial loading animation looks like.</p>

		<figure>
			<img src="images/int.gif" />
		</figure>

		<p>To accomplish this, let’s break down step-by-step what I do to make it happen.</p>

		<ol>
			<li>If the data comes back and I call <code>[self.tableView reloadData]</code>, it’ll immediately show up and be visible to the user. So I first make the table have an opacity of 0 so I can manipulate it without the user seeing anything until I want them to.</li>
			<li>I then call <code>[self.tableView reloadData]</code> which loads the table’s rows up with the data, and at this point all the rows are in their normal positions, but since the whole table has an opacity of 0 and is hidden, nothing is visible on the screen.</li>
			<li>I loop across the rows that are currently visible on the screen and move the <code>UITableViewCell</code> that represents the row off the bottom of the screen. I do that by changing its position to be moved downwards the exact height of the entire tableview so every row is off the bottom of the screen.</li>
			<li>Now that the rows are all off the bottom of the screen, I make the table visible again by changing the alpha back to 1.0. The table is now visible but all the rows are off the screen so no articles are visible yet.</li>
			<li>Finally, I iterate again across all the rows that I pushed off the bottom of the screen, and I animate them back up into their original positions by removing the transform that I initially set on them.</li>
		</ol>

		<p>Whew! That’s a decent number of steps for a fairly simple-looking effect. Here’s the code that accomplishes those steps, line by line.</p>

		<pre>// Make the table invisible, then reload its data
self.tableView.alpha = 0.0f;
[self.tableView reloadData];

// Store a delta timing variable so I can tweak the timing delay
// between each row’s animation and some additional 
CGFloat diff = .05;
CGFloat tableHeight = self.tableView.bounds.size.height;
NSArray *cells = [self.tableView visibleCells];

// Iterate across the rows and translate them down off the screen
for (NSUInteger a = 0; a < [cells count]; a++) {
    UITableViewCell *cell = [cells objectAtIndex:a];
    if ([cell isKindOfClass:[UITableViewCell class]]) {

        // Move each cell off the bottom of the screen by translating its Y position
        cell.transform = CGAffineTransformMakeTranslation(0, tableHeight);
    }
}

// Now that all rows are off the screen, make the tableview opaque again
self.tableView.alpha = 1.0f;

// Animate each row back into place
for (NSUInteger b = 0; b < [cells count]; b++) {
    UITableViewCell *cell = [cells objectAtIndex:b];
	
    [UIView animateWithDuration:1.6 delay:diff*b usingSpringWithDamping:0.77
        initialSpringVelocity:0 options:0 animations:^{
        cell.transform = CGAffineTransformMakeTranslation(0, 0);
     } completion:NULL];
}</pre>

		<p>If you notice in the 2nd for loop, in the animation block, my <code>delay</code> value is set to <code>diff * b</code>. Because I’m in a loop, I can use the loop’s counter variable <code>b</code> to keep the animation timing in sync, by just multiplying it by the time difference between each row I’m animating. That will insure that there’s the same time difference between each row’s animation which will generate the nice, wave-like pattern. And that’s all there is to it!</p>

		<p style="border-top: double #e5e5e5; padding-top: 2em;">It’s time to change gears.</p>

		<p>So far, we’ve been using Core Animation to create our animated interfaces. Whether we were using iOS 7’s new block-based animation methods with spring damping, or the nifty JNWSpringAnimation framework which created <code>CAKeyframeAnimation</code>s for us, we were still in the realm of Core Animation, Apple’s mega framework that manages so many pieces of the interface rendering puzzle that is iOS.</p>

		<p>But there’s more than one way to skin a cat, so to speak, and there are other ways to create motion on the screen of an iOS app that don’t involve using Apple’s Core Animation framework.</p>

		<p>One of these other methods of animation has gotten a lot of attention recently, and for good reason. It’s a real breath of fresh air in the iOS animation framework world, and is already being used to build wonderful animations into some of the most-used apps in the entire world.</p>

		<p>Of course I’m talking about the brilliant <a href="https://github.com/facebook/pop">Pop</a> framework by Facebook.</p>

		<p>Are you ready to learn something brand new? Let’s do it!</p>

		<a class="next-section" href="guide-6.html">CONTINUE</a>

	</section>

	</div>
</body>
</html>